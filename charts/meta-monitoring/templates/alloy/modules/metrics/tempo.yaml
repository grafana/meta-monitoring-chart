{{- if .Values.alloy.metrics.tempo.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: tempo-metrics
  namespace: {{ .Release.Namespace }}
data:
  tempo: |
    /*
    Module: job-tempo
    Description: Scrapes tempo

    Note: Every argument except for "forward_to" is optional, and does have a defined default value.  However, the values for these
          arguments are not defined using the default = " ... " argument syntax, but rather using the coalesce(argument.value, " ... ").
          This is because if the argument passed in from another consuming module is set to null, the default = " ... " syntax will
          does not override the value passed in, where coalesce() will return the first non-null value.
    */
    declare "kubernetes" {
      // arguments for kubernetes discovery
      argument "namespaces" {
        comment = "The namespaces to look for targets in (default: [] is all namespaces)"
        optional = true
      }

      argument "field_selectors" {
        // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        comment = "The label selectors to use to find matching targets (default: [])"
        optional = true
      }

      argument "label_selectors" {
        // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        comment = "The label selectors to use to find matching targets (default: [\"app.kubernetes.io/name=tempo\"])"
        optional = true
      }

      argument "port_name" {
        comment = "The of the port to scrape metrics from (default: http-metrics)"
        optional = true
      }

      // tempo service discovery for all of the pods
      discovery.kubernetes "tempo" {
        role = "pod"

        selectors {
          role = "pod"
          field = join(coalesce(argument.field_selectors.value, []), ",")
          label = join(coalesce(argument.label_selectors.value, ["app.kubernetes.io/name=tempo"]), ",")
        }

        namespaces {
          names = coalesce(argument.namespaces.value, [])
        }
      }

      // tempo relabelings (pre-scrape)
      discovery.relabel "kubernetes" {
        targets = discovery.kubernetes.tempo.targets

        // keep only the specified metrics port name, and pods that are Running and ready
        rule {
          source_labels = [
            "__meta_kubernetes_pod_container_port_name",
            "__meta_kubernetes_pod_phase",
            "__meta_kubernetes_pod_ready",
            "__meta_kubernetes_pod_container_init",
          ]
          separator = "@"
          regex = coalesce(argument.port_name.value, "http-metrics") + "@Running@true@false"
          action = "keep"
        }

        // set the namespace label
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          target_label  = "namespace"
        }

        // set the pod label
        rule {
          source_labels = ["__meta_kubernetes_pod_name"]
          target_label  = "pod"
        }

        // set the container label
        rule {
          source_labels = ["__meta_kubernetes_pod_container_name"]
          target_label  = "container"
        }

        // set a workload label
        rule {
          source_labels = [
            "__meta_kubernetes_pod_controller_kind",
            "__meta_kubernetes_pod_controller_name",
          ]
          separator = "/"
          target_label  = "workload"
        }
        // remove the hash from the ReplicaSet
        rule {
          source_labels = ["workload"]
          regex = "(ReplicaSet/.+)-.+"
          target_label  = "workload"
        }

        // set the app name if specified as metadata labels "app:" or "app.kubernetes.io/name:" or "k8s-app:"
        rule {
          action = "replace"
          source_labels = [
            "__meta_kubernetes_pod_label_app_kubernetes_io_name",
            "__meta_kubernetes_pod_label_k8s_app",
            "__meta_kubernetes_pod_label_app",
          ]
          separator = ";"
          regex = "^(?:;*)?([^;]+).*$"
          replacement = "$1"
          target_label = "app"
        }

        // set the component if specified as metadata labels "component:" or "app.kubernetes.io/component:" or "k8s-component:"
        rule {
          action = "replace"
          source_labels = [
            "__meta_kubernetes_pod_label_app_kubernetes_io_component",
            "__meta_kubernetes_pod_label_k8s_component",
            "__meta_kubernetes_pod_label_component",
          ]
          regex = "^(?:;*)?([^;]+).*$"
          replacement = "$1"
          target_label = "component"
        }

        // set a source label
        rule {
          action = "replace"
          replacement = "kubernetes"
          target_label = "source"
        }
      }

      export "output" {
        value = discovery.relabel.kubernetes.output
      }
    }

    declare "local" {

      argument "port_name" {
        comment = "The port to use (default: 3200)"
        optional = true
      }

      // arguments for local (static)
      discovery.relabel "local" {
        targets = [
          {
            "__address__" = "localhost" + format("%s", coalesce(argument.port.value, "3200")),
            "source" = "local",
          },
        ]
      }

      export "output" {
        value = discovery.relabel.local.output
      }
    }

    declare "scrape" {
      argument "targets" {
        comment = "Must be a list() of targets"
      }

      argument "forward_to" {
        comment = "Must be a list(MetricsReceiver) where collected logs should be forwarded to"
      }

      argument "job_label" {
        comment = "The job label to add for all tempo metric (default: integrations/tempo)"
        optional = true
      }

      argument "keep_metrics" {
        comment = "A regular expression of metrics to keep (default: see below)"
        optional = true
      }

      argument "drop_metrics" {
        comment = "A regular expression of metrics to drop (default: see below)"
        optional = true
      }

      argument "scrape_interval" {
        comment = "How often to scrape metrics from the targets (default: 60s)"
        optional = true
      }

      argument "scrape_timeout" {
        comment = "How long before a scrape times out (default: 10s)"
        optional = true
      }

      argument "max_cache_size" {
        comment = "The maximum number of elements to hold in the relabeling cache (default: 100000).  This should be at least 2x-5x your largest scrape target or samples appended rate."
        optional = true
      }

      argument "clustering" {
        // Docs: https://grafana.com/docs/agent/latest/flow/concepts/clustering/
        comment = "Whether or not clustering should be enabled (default: false)"
        optional = true
      }

      // tempo scrape job
      prometheus.scrape "tempo" {
        job_name = coalesce(argument.job_label.value, "integrations/tempo")
        forward_to = [prometheus.relabel.tempo.receiver]
        targets = argument.targets.value
        scrape_interval = coalesce(argument.scrape_interval.value, "60s")
        scrape_timeout = coalesce(argument.scrape_timeout.value, "10s")

        clustering {
          enabled = coalesce(argument.clustering.value, false)
        }
      }

      // tempo metric relabelings (post-scrape)
      prometheus.relabel "tempo" {
        forward_to = argument.forward_to.value
        max_cache_size = coalesce(argument.max_cache_size.value, 100000)

        // drop metrics that match the drop_metrics regex
        rule {
          source_labels = ["__name__"]
          regex = coalesce(argument.drop_metrics.value, "(^(go|process)_.+$)")
          action = "drop"
        }

        // keep only metrics that match the keep_metrics regex
        rule {
          source_labels = ["__name__"]
          regex = coalesce(argument.keep_metrics.value, "(.+)")
          action = "keep"
        }

        // set the job label to be namespace/pod as this is what the cloud integration expects
        rule {
          action = "replace"
          source_labels = [
            "namespace",
            "workload",
          ]
          separator = "/"
          regex = "(.+)/.+/(.+)"
          replacement = "$1/$2"
          target_label = "job"
        }

        rule {
          action = "labelkeep"
          regex = "__name__|job|component|app|workload|namespace|pod|container|route|tenant|status|le|operation"
        }
      }
    }
{{- end }}
