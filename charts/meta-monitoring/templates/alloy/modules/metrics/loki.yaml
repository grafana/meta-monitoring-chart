{{- if .Values.alloy.metrics.loki.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: loki-metrics
  namespace: {{ .Release.Namespace }}
data:
  loki: |
    declare "kubernetes" {
      // arguments for kubernetes discovery
      argument "namespaces" {
        comment = "The namespaces to look for targets in (default: [] is all namespaces)"
        optional = true
      }

      argument "port_name" {
        comment = "The of the port to scrape metrics from (default: http-metrics)"
        optional = true
      }

      // loki service discovery for all of the pods
      discovery.kubernetes "loki" {
        role = "pod"

        namespaces {
          names = coalesce(argument.namespaces.value, [])
        }
      }

      // loki relabelings (pre-scrape)
      discovery.relabel "kubernetes" {
        targets = discovery.kubernetes.loki.targets

        // keep only the specified metrics port name, and pods that are Running and ready
        rule {
          source_labels = [
            "__meta_kubernetes_pod_container_port_name",
            "__meta_kubernetes_pod_phase",
            "__meta_kubernetes_pod_ready",
            "__meta_kubernetes_pod_container_init",
          ]
          separator = "@"
          regex = coalesce(argument.port_name.value, "http-metrics") + "@Running@true@false"
          action = "keep"
        }

        rule {
          action = "replace"
          source_labels = ["__meta_kubernetes_pod_node_name"]
          target_label = "__host__"
        }

        rule {
          action = "labelmap"
          regex = "__meta_kubernetes_pod_label_(.+)"
        }

        // make all annotations on the pod available to the pipeline as labels,
        // they are omitted before write via labelallow unless explicitly set
        rule {
          action = "labelmap"
          regex = "__meta_kubernetes_pod_annotation_(.+)"
        }

        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          target_label  = "namespace"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_name"]
          target_label  = "pod"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_container_name"]
          target_label  = "container"
        }

        rule {
          source_labels = [
            "__meta_kubernetes_pod_controller_kind",
            "__meta_kubernetes_pod_controller_name",
          ]
          separator = "/"
          target_label  = "workload"
        }

        rule {
          source_labels = ["workload"]
          regex = "(ReplicaSet/.+)-.+"
          target_label  = "workload"
        }

        rule {
          action = "replace"
          source_labels = [
            "__meta_kubernetes_pod_label_app_kubernetes_io_name",
            "__meta_kubernetes_pod_label_k8s_app",
            "__meta_kubernetes_pod_label_app",
          ]
          separator = ";"
          regex = "^(?:;*)?([^;]+).*$"
          replacement = "$1"
          target_label = "app"
        }

        rule {
          action = "replace"
          source_labels = [
            "__meta_kubernetes_pod_label_app_kubernetes_io_component",
            "__meta_kubernetes_pod_label_k8s_component",
            "__meta_kubernetes_pod_label_component",
          ]
          regex = "^(?:;*)?([^;]+).*$"
          replacement = "$1"
          target_label = "component"
        }

        rule {
          action = "replace"
          source_labels = [
            "workload",
            "__meta_kubernetes_namespace",
          ]
          regex = ".+\\/(.+);(.+)"
          replacement = "$2/$1"
          target_label = "job"
        }
      }

      export "output" {
        value = discovery.relabel.kubernetes.output
      }
    }

    declare "local" {

      argument "port_name" {
        comment = "The port to use (default: 3000)"
        optional = true
      }

      // arguments for local (static)
      discovery.relabel "local" {
        targets = [
          {
            "__address__" = "localhost" + format("%s", coalesce(argument.port.value, "3000")),
            "source" = "local",
          },
        ]
      }

      export "output" {
        value = discovery.relabel.local.output
      }
    }

    declare "scrape" {
      argument "targets" {
        comment = "Must be a list() of targets"
      }

      argument "forward_to" {
        comment = "Must be a list(MetricsReceiver) where collected logs should be forwarded to"
      }

      argument "job_label" {
        comment = "The job label to add for all loki metric (default: integrations/loki)"
        optional = true
      }

      argument "keep_metrics" {
        comment = "A regular expression of metrics to keep (default: see below)"
        optional = true
      }

      argument "drop_metrics" {
        comment = "A regular expression of metrics to drop (default: see below)"
        optional = true
      }

      argument "scrape_interval" {
        comment = "How often to scrape metrics from the targets (default: 60s)"
        optional = true
      }

      argument "scrape_timeout" {
        comment = "How long before a scrape times out (default: 10s)"
        optional = true
      }

      argument "max_cache_size" {
        comment = "The maximum number of elements to hold in the relabeling cache (default: 100000).  This should be at least 2x-5x your largest scrape target or samples appended rate."
        optional = true
      }

      argument "clustering" {
        // Docs: https://grafana.com/docs/agent/latest/flow/concepts/clustering/
        comment = "Whether or not clustering should be enabled (default: false)"
        optional = true
      }

      // loki scrape job
      prometheus.scrape "loki" {
        job_name = coalesce(argument.job_label.value, "integrations/loki")
        forward_to = [prometheus.relabel.loki.receiver]
        targets = argument.targets.value
        scrape_interval = coalesce(argument.scrape_interval.value, "60s")
        scrape_timeout = coalesce(argument.scrape_timeout.value, "10s")

        clustering {
          enabled = coalesce(argument.clustering.value, false)
        }
      }

      // loki metric relabelings (post-scrape)
      prometheus.relabel "loki" {
        forward_to = argument.forward_to.value
        max_cache_size = coalesce(argument.max_cache_size.value, 100000)

        // drop metrics that match the drop_metrics regex
        rule {
          source_labels = ["__name__"]
          regex = coalesce(argument.drop_metrics.value, "(^(go|process)_.+$)")
          action = "drop"
        }

        // keep only metrics that match the keep_metrics regex
        rule {
          source_labels = ["__name__"]
          regex = coalesce(argument.keep_metrics.value, "(.+)")
          action = "keep"
        }

        // set the job label to be namespace/pod as this is what the cloud integration expects
        rule {
          action = "replace"
          source_labels = [
            "namespace",
            "workload",
          ]
          separator = "/"
          regex = "(.+)/.+/(.+)"
          replacement = "$1/$2"
          target_label = "job"
        }

        rule {
          action = "labelkeep"
          regex = "__name__|job|component|app|workload|namespace|pod|container|route|tenant|status|le|operation"
        }
      }
    }

{{- end }}
